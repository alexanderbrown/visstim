% Visual Stimulation Script - Alex Brown, v2.4 April 2011
%
% Adapted from Bruno Pichler's Grating Script

function [stimulusInfo, filePath] = VisStimAlex(varargin)
% --------------------------------- Setup---------------------------------
% Creates input parser and starts the Pyschophysics Toolbox
%clear mex   

[window,screenRect,ifi,whichScreen]=initScreen; %Returns a handle to the active screen, a rectangle representing size, 
 
p=inputParser;
% ------------------------ Program  Setup ---------------------------------

% Whether or not to wait for keypresses at the beginning and end. Default
% is not to (0)
p.addParamValue('keyWait', 0)

% Whether or not to clear the screen at the end. Default is yes (1)
p.addParamValue('screenClear', 1)

% --------------- Configuration Variables ---------------------------------


%%%%Experiment mode%%%%%%
% If you leave all configuration parameters alone, you can switch what
% stimulus you are using by specifying mode here.
%
% Flip: Screen flips between a total white rectangle and blackness. Useful
%       for maximal stimulation and assessing optical noise
% D:    Dynamic grating of fixed spatial and temporal frequency (specified as
%       parameters below) but changing orientation. 
%       randomisation mode and number of repeats in each run
% DH:   Dynamic grating followed by a hold, both at the same orientation,
%       then on to the next orientation 
% HDH:  Hold then dynamic then hold, all at the same orientation, then on 
%       to the next orientation. 
% Ret: Retinotopy stimulus
p.addParamValue('experimentType', 'HD');

% If triggering is 'off', the stimulus will be generated by timings specified
% below. If it is 'on', state changes will occur on a trigger from the
% acquisition computer. Triggers only occur once per cycle, so state
% changes within a cycle (e.g. drift -> hold in DH) are carried out after a
% specified time. See individual functions for more details.

p.addParamValue('triggering', 'off');

% photoDiode 'on' will display a patch for photodiode readout. 'off' means
% no patch will be displayed
p.addParamValue('photoDiode', 'on');


% Grating parameters:
p.addParamValue('gratingType', 0);                           % 0 creates sine grating, 1 creates square wave grating
p.addParamValue('spaceFreqDeg',0.05);                        % spatial frequency in cycles / degree
p.addParamValue('tempFreq',2);                               % temporal frequency in Hz
p.addParamValue('directionsNum',4);                          % Number of different directions to display

%Run parameters
p.addParamValue('baseLineTime', 2);
p.addParamValue('repeats', 2);                               % Number of repeats within each run
p.addParamValue('randMode', 3);                               % Randomisation of stimulus order. (not applicable to Flip)
                                            %             0 = orderly presentation (not recommended). 
                                            %             1 = random permutation, kept constant throughout one run
                                            %             2 = new random permutation on each repetition
                                            %             3 = maximally different directions 
                                                              
% Experiment type specific parameters
p.addParamValue('preDriftHoldTime', 1);                        % How long to hold the grating for, in seconds, before a drift
p.addParamValue('driftTime', 2);                              % How long to display a drifting grating for
p.addParamValue('postDriftHoldTime', 1);                    % How long to hold the grating for, in seconds, after a drift
p.addParamValue('flipTime', 0.5);                             % How long each state (white or black) should be displayed for in flipStimulus


% Screen parameters:
p.addParamValue('screenWidthCm', 56);                          % screen size in cm
p.addParamValue('mouseDistanceCm', 19);                       % mouse distance from the screen im cm

% Photodiode indicator patch settings
p.addParamValue('diodePatchXSize', 100);
p.addParamValue('diodePatchYSize', 100);

% Baseline parameters
p.addParamValue('startBsl',10);
p.addParamValue('endBsl',10);

% Retinotopy parameters
p.addParamValue('retinotopyType', 'D')                          %Which type of retinotopy to run:
                                                                                        %D = drifts
                                                                                        %Flip = flips
p.addParamValue('patchGridDimensions', [6 4])                              % The size of the grid to divide the visual field by - [x y]
p.addParamValue('retinotopyRandMode', 0)                       % Same as randMode, but for the order of patch presentation

% --------------- System Parameters ---------------
% There should not, normally, be any reason for these to be changed.

%NI card parameters
p.addParamValue('inputLine', 3);
p.addParamValue('inputPort', 1);
p.addParamValue('deviceName','Dev1');

%--------------------Parse Inputs------------------------------------------
% q is a struct containing all inputted or default parameters
try
    p.parse(varargin{:});
    q = p.Results;
catch    
    clear mex
    fprintf('Parameter not found \n')
    return
end
% --------------- Calculated Properties ---------------

% Screen & Distance 
% screenCenter = [(screenRect(3)-screenRect(1)) (screenRect(4)-screenRect(2))]/2; %Screen Centre in pixels
pixelsPerCm = screenRect(3) / q.screenWidthCm;             % Scaling factor for conversion between pixels and cm
mouseDistancePixels = q.mouseDistanceCm .*pixelsPerCm;    % Convert the mouse distance from the screen in to pixels
spaceFreqPixels = 1 / (2* mouseDistancePixels * tan((1 / q.spaceFreqDeg) * pi / 180 / 2));

hz = 1/ifi;                                             % Screen flip frequency

%Photodiode display area
if strcmp(q.photoDiode, 'on')
    photoDiodeRect = [0 screenRect(4)-q.diodePatchYSize q.diodePatchXSize screenRect(4)];
else
    photoDiodeRect = [0 0 0 0];
end
  
% --------------- The Program Itself ---------------


startTime=datestr(now, 'yyyy/mm/dd HH:MM:SS.FFF');       % Records start time
output = sprintf(strcat('\r----------------', startTime, '-------------------\r\r')); %outputs start time
disp(output)
clear output;
HideCursor;   

priorityLevel=MaxPriority(window);                      % Needed to ensure maximum performance
Priority(priorityLevel);
   
Screen('FillRect', window,127);                         % Grey Background for initialisation
Screen('Flip',window);

% Generate the grating itself
g=127+127*GratingAlex(q.gratingType,(screenRect(1)+1:screenRect(3)*2), (screenRect(2)+1:screenRect(4)*2), 0, spaceFreqPixels);
gratingtex=Screen('MakeTexture', window, g);

%Decide where we're going to save it
fileName = datestr(now, 'yyyymmdd_HH_MM_SS');

% We're ready. Wait for a keypress if we're in keyWait mode
if q.keyWait
    KbWait;
end

%Choose which stimulus function to call based on whether triggering is on,
%and on experiment type
switch q.triggering
    case 'off'
        switch q.experimentType
            case 'Flip'
                stimulusInfo = flipStimulus(window, hz, q.baseLineTime, q.repeats, q.flipTime);
                stimulusInfo.flipTime = q.flipTime;
            case 'D'
                stimulusInfo = Drift(q.randMode, hz, screenRect,window, q.baseLineTime, q.driftTime,  q.directionsNum, spaceFreqPixels, q.tempFreq, gratingtex, q.repeats, photoDiodeRect);
                stimulusInfo.driftTime = q.driftTime;
            case 'DH'
                stimulusInfo = DriftHold(q.randMode, hz, screenRect, window, q.baseLineTime,q.driftTime, q.postDriftHoldTime,  q.directionsNum, spaceFreqPixels, q.tempFreq, gratingtex, q.repeats, photoDiodeRect);
                stimulusInfo.driftTime = q.driftTime; 
                stimulusInfo.postDriftHoldTime = q.postDriftHoldTime;
            case 'HD'
                stimulusInfo = HoldDrift(q.randMode, hz, screenRect, window, q.baseLineTime,q.preDriftHoldTime,q.driftTime,  q.directionsNum, spaceFreqPixels, q.tempFreq, gratingtex, q.repeats, photoDiodeRect);
                stimulusInfo.preDriftHoldTime = q.preDriftHoldTime;
                stimulusInfo.driftTime = q.driftTime;
            case 'HDH'
                stimulusInfo = HoldDriftHold(q.randMode, hz, screenRect, window, q.baseLineTime,  q.preDriftHoldTime, q.driftTime, q.postDriftHoldTime, q.directionsNum, spaceFreqPixels, q.tempFreq, gratingtex, q.repeats, photoDiodeRect);
                stimulusInfo.preDriftHoldTime = q.preDriftHoldTime;
                stimulusInfo.driftTime = q.driftTime; 
                stimulusInfo.postDriftHoldTime = q.postDriftHoldTime;
            case 'Ret'
                stimulusInfo = RetinotopyDrift(q.randMode, q.retinotopyRandMode, q.patchGridDimensions,hz, screenRect, window, q.baseLineTime, q.driftTime, q.directionsNum, spaceFreqPixels, q.tempFreq, gratingtex, q.repeats, photoDiodeRect);
                
        end
    case 'on'
        switch q.experimentType
            case 'Flip'
                stimulusInfo = flipSimulusTriggered(window, q.repeats, q.inputLine, q.inputPort, q.deviceName);
                stimulusInfo.flipTime = q.flipTime;
            case 'D'
                stimulusInfo = DriftTriggered(q.randMode, hz, screenRect, window, q.directionsNum, spaceFreqPixels, q.tempFreq, gratingtex, q.repeats, q.inputLine, q.inputPort, q.deviceName, photoDiodeRect);
                stimulusInfo.driftTime = q.driftTime; 
            case 'DH'
                stimulusInfo = DriftHoldTriggered(q.randMode, hz, screenRect, window,q.driftTime,  q.directionsNum, spaceFreqPixels, q.tempFreq, gratingtex, q.repeats, q.inputLine, q.inputPort, q.deviceName, photoDiodeRect);
                stimulusInfo.driftTime = q.driftTime; 
                stimulusInfo.postDriftHoldTime = q.postDriftHoldTime;
            case 'HD'
                stimulusInfo = HoldDriftTriggered(q.randMode, hz, screenRect, window,  q.preDriftHoldTime, q.directionsNum, spaceFreqPixels, q.tempFreq, gratingtex, q.repeats, q.inputLine, q.inputPort, q.deviceName, photoDiodeRect);
                stimulusInfo.preDriftHoldTime = q.preDriftHoldTime;
                stimulusInfo.driftTime = q.driftTime; 
            case 'HDH'
                stimulusInfo = HoldDriftHoldTriggered(q.randMode, hz, screenRect, window,  q.preDriftHoldTime, q.driftTime, q.directionsNum, spaceFreqPixels, q.tempFreq, gratingtex, q.repeats, q.inputLine, q.inputPort, q.deviceName, photoDiodeRect);
                stimulusInfo.preDriftHoldTime = q.preDriftHoldTime;
                stimulusInfo.driftTime = q.driftTime; 
                stimulusInfo.postDriftHoldTime = q.postDriftHoldTime;
        end
end

% Unless it's a flip (in which case it's irrelevant), add temporal and
% spatial frequency to the output variable
if ~(strcmp(q.experimentType, 'Flip'))
    stimulusInfo.temporalFreq = q.tempFreq;
    stimulusInfo.spatialFreq = q.spaceFreqDeg;
    
    %add a vector to stimulusInfo containing all the directions in order
    directions = zeros(2, size(stimulusInfo.stimuli, 2));
    for i = 1:size(stimulusInfo.stimuli, 2)
        directions(1, i) = stimulusInfo.stimuli(i).direction;
        if strcmp(stimulusInfo.stimuli(1, i).type,'Drift')
            directions(2, i) = 1;
        else
            directions(2, i) = 0;
        end
    end
    stimulusInfo.directions = directions;
end

filePath = strcat('C:\Users\Bruno\Documents\MATLAB\', fileName);
save(filePath, 'stimulusInfo')

if q.keyWait
    KbWait;
end

if q.screenClear
    Screen('CloseAll')
    clear mex
else
    Screen('FillRect', window,127);                         % Grey Background for initialisation
    Screen('Flip',window);
end
